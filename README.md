# 낙관적 락, 비관적 락 동시성 제어 성능 비교
<details>
<summary><b>동시성 이슈 및 제어 방식</b></summary>

### 1. 발생할 수 있는 동시성 이슈

- **좌석 예약 요청**: 여러 사용자가 동시에 동일한 좌석을 예약하려고 시도할 때 발생하는 충돌.
- **결제 처리 및 결제 내역 생성**: 따닥(?)과 같은 동일한 예약 건에 대해 결제를 시도할 때 발생하는 충돌.

### 2. 동시성 제어 방식 및 장단점

#### 비관적 락 (Pessimistic Lock)

**비관적 락**은 데이터에 접근할 때마다 락을 걸어 충돌을 방지하는 방식, 주로 충돌이 자주 발생하는 환경에서 데이터의 일관성을 보장할 때 사용

**장점**:
- **강력한 데이터 일관성 보장**: 모든 데이터에 락을 걸어 충돌을 방지하므로 데이터의 일관성을 강하게 보장
- **충돌 발생 시 안정적인 처리**: 충돌이 발생하지 않도록 미리 락을 걸어 안정적으로 처리

**단점**:
- **성능 저하 가능성**: 락을 걸고 해제하는 과정에서 성능이 저하될 가능성 있음
- **높은 리소스 소모**: 락을 유지하는 동안 리소스를 많이 소비
- **교착 상태 발생 위험**: 여러 스레드가 서로 다른 리소스를 잠그고, 다른 스레드가 소유한 리소스를 기다리면서 교착 상태가 발생할 가능성 있음

#### 낙관적 락 (Optimistic Lock)

**낙관적 락**은 데이터 충돌이 드물다고 가정하고 데이터 갱신 시 충돌을 감지하는 방식, 충돌이 발생하면 롤백하고 다시 시도

**장점**:
- **높은 성능**: 락을 거의 걸지 않으므로 성능이 높음
- **낮은 리소스 소비**: 락을 유지하지 않으므로 리소스 소비가 적음
- **교착 상태 방지**: 충돌이 발생했을 때 롤백하고 재시도하므로 교착 상태를 방지할 수 있음

**단점**:
- **충돌 발생 시 오버헤드**: 충돌이 발생하면 롤백과 재시도로 인해 오버헤드가 발생할 가능성 있음
- **일관성 보장이 상대적으로 약함**: 충돌이 발생할 가능성이 높은 경우 데이터의 일관성 보장이 상대적으로 약함

### 3. 구현의 복잡도, 성능, 효율성 비교

#### 비관적 락 (Pessimistic Lock)
- **구현의 복잡도**: 상대적으로 간단. 락을 걸고 해제하는 코드가 명확함
- **성능**: 동시성 충돌이 자주 발생하는 환경에서는 안정적이지만, 락으로 인한 성능 저하가 발생할 수 있음
- **효율성**: 리소스 소모가 높고, 교착 상태 발생 위험이 있음

#### 낙관적 락 (Optimistic Lock)
- **구현의 복잡도**: 복잡도가 증가할 수 있음. 충돌 감지와 재시도 로직을 추가해야 함
- **성능**: 대부분의 경우 높은 성능을 유지. 충돌 발생 시 재시도로 인한 오버헤드가 있을 수 있음
- **효율성**: 리소스 소비가 적고, 교착 상태를 방지할 수 있음

### 4. 선택한 동시성 제어 방식

#### `좌석 예약 요청`

  - **낙관적 락 선택**: 비관적 락을 사용하면 많은 사용자가 동시에 좌석을 예약하려고 할 때 교착 상태와 성능 저하가 발생할 것이라 판단, 낙관적 락은 충돌이 발생했을 때만 롤백하고 재시도하기 때문에 사용자의 동시 접근에 대한 영향을 최소화하고 자원 소비 측면에서도 효율적이지 않을까...

***

#### `결제 처리 및 결제 내역 생성`

  - **낙관적 락 선택**: 결제 처리의 경우 동일한 예약에 대해 중복 결제가 발생할 가능성이 낮다고 판단. 동시성 충돌이 드물고, 낙관적 락을 적용하면 데이터 충돌이 발생할 때만 롤백하고 재시도하기 때문에 처리 속도가 빠르고 성능이 우수하지 않을까...

</details>

<details>
<summary><b>낙관적 Lock 테스트 결과</b></summary>

### `좌석 예약 요청`

  - 통합 테스트 실행 시간
![좌석예약요청_낙관적_소요시간](https://github.com/user-attachments/assets/079fa477-99f0-4d23-addd-9fc11e5c34c2)

  - 테스트 결과
![좌석예약요청_낙관적_로그](https://github.com/user-attachments/assets/e2d896a3-4dcd-4bb9-995e-3857714d0950)

***

### `결제 처리 및 결제 내역 생성`

  - 통합 테스트 실행 시간
![결제_낙관적_소요시간](https://github.com/user-attachments/assets/39534b06-f8dc-4f0d-b216-92d714f7fe0b)

  - 테스트 결과
![결제_낙관적_로그1](https://github.com/user-attachments/assets/22c51233-8ce4-4eea-8300-63fbce858a85)
![결제_낙관적_로그2](https://github.com/user-attachments/assets/86bb7d13-daf4-4835-af2f-c55fab4451a2)

</details>

<details>
<summary><b>비관적 Lock 테스트 결과</b></summary>

### `좌석 예약 요청`

  - 소요시간
![좌석예약요청_비관적_소요시간](https://github.com/user-attachments/assets/a7223c78-1c07-4117-8700-38bc8073cf68)

  - 테스트 결과
![좌석예약요청_비관적_로그](https://github.com/user-attachments/assets/e8e2d6d5-0e45-4958-84ae-a52f8a284142)

***

### `결제 처리 및 결제 내역 생성`

  - 소요시간
![결제_비관적_소요시간](https://github.com/user-attachments/assets/268f08c6-ef75-45e9-a119-feba63525a13)

  - 테스트 결과
![결제_비관적_로그](https://github.com/user-attachments/assets/727a1da7-487b-4003-beee-c591881c4d65)

</details>


# 산출물

## [MileStone](https://github.com/users/honesty2223/projects/12)
![MileStone](https://github.com/honesty2223/hhplus-concert-reservation/assets/165884218/b19b47d1-66c8-4008-8794-ed31bcf876f5)

## [ERD](https://dbdiagram.io/d/hhplus-concert-reservation-6686e1ed9939893dae138e70)
![ERD](https://github.com/honesty2223/hhplus-concert-reservation/assets/165884218/8d3891a9-161c-475c-b0a3-5b028c7bc8d2)

## [API 명세서](https://documenter.getpostman.com/view/36570181/2sA3dyhqYp)
![API](https://github.com/honesty2223/hhplus-concert-reservation/assets/165884218/ec2bed66-bbdb-485b-bfc0-59e5c389d960)

## Sequence Diagram
![Sequence Diagram](https://github.com/honesty2223/hhplus-concert-reservation/assets/165884218/c451f225-7d33-409b-b6d8-a54af90055e5)

# [ 3~5주차 과제 ] 콘서트 예약 서비스
<aside>
💡 아래 명세를 잘 읽어보고, 서버를 구현합니다.

</aside>

## Description

- **`콘서트 예약 서비스`**를 구현해 봅니다.
- 대기열 시스템을 구축하고, 예약 서비스는 작업가능한 유저만 수행할 수 있도록 해야합니다.
- 사용자는 좌석예약 시에 미리 충전한 잔액을 이용합니다.
- 좌석 예약 요청시에, 결제가 이루어지지 않더라도 일정 시간동안 다른 유저가 해당 좌석에 접근할 수 없도록 합니다.

## Requirements

- 아래 5가지 API 를 구현합니다.
    - 유저 토큰 발급 API
    - 예약 가능 날짜 / 좌석 API
    - 좌석 예약 요청 API
    - 잔액 충전 / 조회 API
    - 결제 API
- 각 기능 및 제약사항에 대해 단위 테스트를 반드시 하나 이상 작성하도록 합니다.
- 다수의 인스턴스로 어플리케이션이 동작하더라도 기능에 문제가 없도록 작성하도록 합니다.
- 동시성 이슈를 고려하여 구현합니다.
- 대기열 개념을 고려해 구현합니다.

## API Specs

1️⃣ **`주요` 유저 대기열 토큰 기능**

- 서비스를 이용할 토큰을 발급받는 API를 작성합니다.
- 토큰은 유저의 UUID 와 해당 유저의 대기열을 관리할 수 있는 정보 ( 대기 순서 or 잔여 시간 등 ) 를 포함합니다.
- 이후 모든 API 는 위 토큰을 이용해 대기열 검증을 통과해야 이용 가능합니다.

> 기본적으로 폴링으로 본인의 대기열을 확인한다고 가정하며, 다른 방안 또한 고려해보고 구현해 볼 수 있습니다.
> 

**2️⃣ `기본` 예약 가능 날짜 / 좌석 API**

- 예약가능한 날짜와 해당 날짜의 좌석을 조회하는 API 를 각각 작성합니다.
- 예약 가능한 날짜 목록을 조회할 수 있습니다.
- 날짜 정보를 입력받아 예약가능한 좌석정보를 조회할 수 있습니다.

> 좌석 정보는 1 ~ 50 까지의 좌석번호로 관리됩니다.
> 

3️⃣ **`주요` 좌석 예약 요청 API**

- 날짜와 좌석 정보를 입력받아 좌석을 예약 처리하는 API 를 작성합니다.
- 좌석 예약과 동시에 해당 좌석은 그 유저에게 약 5분간 임시 배정됩니다. ( 시간은 정책에 따라 자율적으로 정의합니다. )
- 만약 배정 시간 내에 결제가 완료되지 않는다면 좌석에 대한 임시 배정은 해제되어야 하며 다른 사용자는 예약할 수 없어야 한다.

4️⃣ **`기본`**  **잔액 충전 / 조회 API**

- 결제에 사용될 금액을 API 를 통해 충전하는 API 를 작성합니다.
- 사용자 식별자 및 충전할 금액을 받아 잔액을 충전합니다.
- 사용자 식별자를 통해 해당 사용자의 잔액을 조회합니다.

5️⃣ **`주요` 결제 API**

- 결제 처리하고 결제 내역을 생성하는 API 를 작성합니다.
- 결제가 완료되면 해당 좌석의 소유권을 유저에게 배정하고 대기열 토큰을 만료시킵니다.

<aside>
💡 **KEY POINT**

</aside>

- 유저간 대기열을 요청 순서대로 정확하게 제공할 방법을 고민해 봅니다.
- 동시에 여러 사용자가 예약 요청을 했을 때, 좌석이 중복으로 배정 가능하지 않도록 합니다.
